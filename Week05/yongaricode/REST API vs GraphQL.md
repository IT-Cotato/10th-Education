# REST API vs GraphQL

## 1. API란?

: GraphQL과 REST는 모두 클라이언트-서버 모델에서 서로 다른 서비스 또는 애플리케이션 간에 데이터를 교환할 수 있는 널리 사용되는 API 아키텍처 스타일

- **API는 다음과 같은 데이터 액세스 및 데이터 작업을 지원**
    1. 클라이언트가 서버의 엔드포인트 또는 여러 엔드포인트에 API 요청을 전송
    2. 서버가 데이터, 데이터 상태 또는 오류 코드가 포함된 응답을 제공
- **REST와 GraphQL 모두 몇 가지 일반적인 API 아키텍처 원칙을 구현**
    - 둘 다 상태를 저장하지 않으므로 서버가 요청 간에 응답 기록을 저장하지 않습니다.
    - 둘 다 클라이언트-서버 모델을 사용하므로 단일 클라이언트에서 요청하면 단일 서버에서 응답합니다.
    - 둘 다 기반 통신 프로토콜인 HTTP를 기반으로 합니다.

## 2. REST API

### REST란?

- 자원의 이름으로 구분하여 해당 자원의 상태를 주고받는 통신 방식.
- HTTP 프로토콜을 기반으로 웹의 장점을 최대한 활용.

### REST의 구성 요소

1. **자원(Resource)**: 소프트웨어가 관리하는 모든 것을 의미하며, URI를 통해 접근 가능.
예: `/products/{id}` → 특정 자원을 식별.
2. **행위(Action)**: HTTP 메서드로 정의.
    - GET: 조회
    - POST: 생성
    - DELETE: 삭제
    - PUT: 전체 수정
    - PATCH: 부분 수정
3. **표현(Representation)**: 자원의 상태를 나타내는 데이터(JSON, XML 등).

### REST의 실제 예시 → 코드로 제공

- HTTP 메서드를 통해 특정 자원을 요청하고 JSON 형식으로 데이터를 반환.
- 예: `name=${userName}` 쿼리 파라미터를 통해 특정 사용자의 메시지 요청.

### REST의 특징

1. **Server-Client 구조**: 서버와 클라이언트가 독립적으로 동작.
2. **Stateless**: 서버가 요청 상태를 기억하지 않음.
3. **Cacheable**: 데이터를 캐싱 가능하도록 설계.
4. **Layered System**: 여러 계층을 거쳐 요청 처리 가능.
5. **Uniform Interface**: 일관된 자원 식별 및 조작 방식 제공.
6. **Self-Descriptiveness**: 요청과 응답에 포함된 정보로 API 작동 방식을 이해 가능.

### REST의 단점 → 실제 코드 예시

1. **Over-fetching**: 필요 이상의 데이터를 응답으로 반환.
    - 서버 리소스 소모 증가, 전송 속도 저하.
2. **Under-fetching**: 필요한 정보를 한 번에 받지 못하고 추가 요청이 필요한 상황 발생.
    - 요청 횟수 증가, 로딩 시간 증가.
    

---

## 3. GraphQL

### GraphQL이란?

- API를 위한 쿼리 언어로, 클라이언트가 서버로부터 효율적으로 데이터를 가져올 수 있도록 설계.
- REST API의 Over-fetching 및 Under-fetching 문제를 해결.

### GraphQL의 특징

1. **하나의 엔드포인트**: 모든 요청이 `/graphql`로 통합.
2. **스키마(Schema)**: 데이터 타입을 정의하고 구조화.
    - 서버에서 필수적으로 정의되어야 함.
3. **쿼리 언어**:
    - Query: 데이터를 요청. (REST의 GET과 유사)
    - Mutation: 데이터를 추가, 수정, 삭제. (REST의 POST, PUT, DELETE와 유사)
    - Subscription: 실시간 데이터 처리.
    - Resolver: 데이터를 실제로 가져오는 로직 정의.

### GraphQL의 장점

1. **Over-fetching 해결**: 필요한 데이터만 정확히 요청.
2. **Under-fetching 해결**: 한 번의 요청으로 여러 데이터를 가져옴.
3. **HTTP 요청 횟수 감소**: 효율적인 데이터 전송 가능.
4. **유연성 제공**: 고정된 요청/응답 형식에서 벗어남.

### GraphQL의 단점

1. **고정된 응답이 필요한 경우 비효율적**: 쿼리 크기가 REST보다 커질 수 있음.
2. **필터링 표준 부족**: 요청 데이터 필터링이 어려움.
3. **HTTP 캐싱 전략과의 호환성 부족**: GET 대신 POST 사용으로 인해 발생.

---

## 4. REST와 GraphQL의 비교

| **항목** | **REST** | **GraphQL** |
| --- | --- | --- |
| **엔드포인트** | 자원별로 개별 엔드포인트 | 하나의 엔드포인트(`/graphql`) |
| **요청 방식** | 고정된 요청 구조 | 유연한 쿼리 구조 |
| **Over-fetching** | 발생 가능 | 해결 |
| **Under-fetching** | 발생 가능 | 해결 |
| **HTTP 메서드** | GET, POST, PUT, DELETE | Query, Mutation, Subscription |
| **응답 크기** | 필요 이상의 데이터 포함 가능 | 필요한 데이터만 반환 |
| **캐싱 가능 여부** | HTTP 캐싱(GET 요청) 가능 | POST 요청으로 인해 캐싱 어려움 |
| **실시간 데이터 처리** | 기본적으로 지원하지 않음 | Subscription으로 실시간 데이터 처리 지원 |